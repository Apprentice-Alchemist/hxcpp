#ifdef __has_include
#if __has_include(<version>)
#include <version>

#ifdef __cpp_lib_semaphore
#include <semaphore>
namespace utils {
template <ptrdiff_t LeastMaxValue = std::counting_semaphore<>::max()>
using counting_semaphore = std::counting_semaphore<LeastMaxValue>;
using binary_semaphore = std::binary_semaphore;
}
#endif
#endif
#endif

#if !defined(__cpp_lib_semaphore)
#include <chrono>
#include <condition_variable>
#include <mutex>

namespace utils {
using namespace std;
template <ptrdiff_t LeastMaxValue = numeric_limits<ptrdiff_t>::max()>
class counting_semaphore {
  public:
   static constexpr ptrdiff_t max() noexcept {
      return numeric_limits<ptrdiff_t>::max();
   }

   constexpr explicit counting_semaphore(ptrdiff_t desired) : counter(desired) {}
   ~counting_semaphore() {}

   counting_semaphore(const counting_semaphore&) = delete;
   counting_semaphore& operator=(const counting_semaphore&) = delete;

   void release(ptrdiff_t update = 1) {
      std::unique_lock<std::mutex> lock(m);
      ptrdiff_t prev_counter = counter;
      counter += update;
      if (prev_counter <= 0) {
         if (update > 1) {
            c.notify_all();
         } else {
            c.notify_one();
         }
      }
   }
   void acquire() {
      std::unique_lock<std::mutex> lock(m);
      c.wait(lock, [this] { return counter > 0; });
      // counter is greater than zero, decrement
      counter--;
   }
   bool try_acquire() noexcept {
      std::unique_lock<std::mutex> lock(m);
      if (counter > 0) {
         counter--;
         return true;
      } else {
         return false;
      }
   }
   template <class Rep, class Period>
   bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time) {
      std::unique_lock<std::mutex> lock(m);
      if (c.wait_for(lock, rel_time, [this] { return counter > 0; })) {
         // counter is greater than zero, decrement
         counter--;
         return true;
      } else {
         return false;
      }
   }
   template <class Clock, class Duration>
   bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time) {
      if (c.wait_for(lock, abs_time, [this] { return counter > 0; })) {
         // counter is greater than zero, decrement
         counter--;
         return true;
      } else {
         return false;
      }
   }

  private:
   std::mutex m;
   std::condition_variable c;
   ptrdiff_t counter;
};
using binary_semaphore = counting_semaphore<1>;
}  // namespace utils
#endif